package com.example.mobileapp.ui.screens.contacts

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mobileapp.helpers.UserHelper
import com.example.mobileapp.model.ChatterInfo
import com.example.mobileapp.model.Contact
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ServerValue
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await

class ContactsViewModel : ViewModel() {

    private val _contacts = MutableStateFlow<List<Contact>>(emptyList())
    val contacts: StateFlow<List<Contact>> = _contacts.asStateFlow()
    private val currentUid = UserHelper().getCurrentUid()

    private companion object {
        const val TAG = "ContactsViewModel"
        const val PATH_CHATS = "chats"
        const val PATH_CHATTERS = "chatters"
        const val PATH_CREATED_AT = "createdAt"
        const val PATH_UPDATED_AT = "updatedAt"
    }

    private val firestore = FirebaseFirestore.getInstance()
    private val usersCollection = firestore.collection("users")

    private val db = FirebaseDatabase.getInstance("https://mobileapp-d2bf2-default-rtdb.europe-west1.firebasedatabase.app")
    private val chatsRef = db.getReference(PATH_CHATS)

    init {
        loadContacts()
    }

    // Doesnt have matching yet
    private fun loadContacts() {
        viewModelScope.launch {
            try {
                val snapshot = usersCollection.get().await()
                _contacts.value = snapshot.documents.mapNotNull { document ->
                    // Filters everyone other than yourself atm
                    val userId = document.id.takeIf { it != currentUid }
                    userId?.let {
                        Contact(
                            uid = it,
                            name = document.getString("username") ?: "Unknown"
                        )
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to load contacts", e)
            }
        }
    }

    suspend fun getChat(selectedContact: Contact): String {
        // Sorts (timestamped) ids generated by firebase so they are in same order always.
        try {
            val chatId = listOf(currentUid, selectedContact.uid).sorted().joinToString("_")

            return if (chatExists(chatId)){
                Log.d(TAG, "Existing chat found. id: $chatId")
                chatId
            } else {
                Log.d(TAG, "Generating new chat. id: $chatId")
                createChat(chatId, selectedContact)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to get chat", e)
            throw e
        }
    }

    private suspend fun chatExists(chatId: String): Boolean {
        return try {
            chatsRef.child(chatId).get().await().exists()
        } catch (e: Exception) {
            Log.e(TAG, "chatExists check failed", e)
            false
        }
    }

    private suspend fun createChat(chatId: String, selectedContact: Contact): String {
        val chatMetaData = mapOf(
            PATH_CREATED_AT to ServerValue.TIMESTAMP,
            PATH_UPDATED_AT to ServerValue.TIMESTAMP,
            PATH_CHATTERS to mapOf(
                currentUid to ChatterInfo(currentUid, UserHelper().getCurrentUsername()),
                selectedContact.uid to ChatterInfo(selectedContact.uid, selectedContact.name)
            )
        )

        return try {
            chatsRef.child(chatId).updateChildren(chatMetaData).await()
            chatId
        } catch (e: Exception) {
            Log.e(TAG, "Error creating chat for chatId: $chatId", e)
            throw e
        }
    }
}